常见的缓存策略（Caching Strategies），分为读策略，写策略还有他们的结合。

## 读策略

### cache-aside

缓存和数据库独立。

客户端访问缓存，有数据就直接返回。没有数据，客户端查询数据库，然后把数据塞进缓存。

好处：

- 缓存里的数据可以和数据库里的在结构上是异构的
- 读多写少的时候性能不错

缺点：

- 更新缓存是程序自己的责任
- 数据可能需要预热，否则服务刚启动的一段时间内总是会cache miss导致请求到数据库

### Read-Through

和cache-aside差不多，但更新缓存的工作交给了操作缓存的库或者缓存服务自身去做。

缺点：

- 缓存里的数据和数据库里的得是同构的，灵活性降低

## 写策略

### Write-Through

应用不直接操作数据库，而是先把要更新的数据写进缓存，然后缓存再直接写进数据库。

优点：

- 配合Read-Through一起用可以一定程度上保证缓存和数据库的一致
- 简单，应用程序只需要操作缓存，不需要操心数据库
- 大量同步的写入，可能导致较大压力

坏处：

- 更新的数据写入数据库有延迟，而且cache在这途中挂了数据最终不能入库导致丢失
- 数据得同构，且用的库或者缓存服务得支持这两种操作

### Write-Back

写入数据库是异步的，甚至可以合并掉一部分写操作。

优点：

- 对于写入量大的系统，这样性能更高压力更小

缺点：

- 写入延迟更高

### Write-around

应用只向数据库写入数据（创建、更新等），读取的时候和cache-aside或者read-through一样。

如果读选择了cache-aside，则在缓存没命中的时候需要应用自己读数据库然后把数据写入缓存。

最常用的就是这种。

## 缓存一致性

以数据库里持久化保存的数据为准。

实时强一致性不可能，所以需要可以容忍缓存有一定的滞后性。

缓存数据需要带过期时间。

更新数据的时候采用双删（入库前删，入库成功后再删），可能需要一点延时，延时加在第二次删除前，因为db的主从同步需要一点时间，不延时从库里的还是旧数据。

不使用延时双删的话就要在写入db成功后做删除，或者用消息队列之类的玩意儿去通知缓存已过期。或者用分布式锁，更新的时候锁死其他。

## 穿透、击穿、雪崩

雪崩：短时间内大量key失效。
解决方案：过期时间加随机数打匀、熔断限流
如何发现：看监控，缓存里有大量key在短时间内过期应该很容易从监控图表上发现

击穿：个别热点key过期，大量请求到了db上
解决方案：分布式锁或者其他什么锁让只有一个请求到db，其他在解锁后不去db而是读缓存、singleflight、热点key永不过期（不推荐）
如何发现：数据库请求量和负载短时间内突然增高然后下降，但缓存里没有大量数据在该时间段内过期

穿透：大量请求缓存里没有的数据，导致请求穿过缓存到了数据库
解决方案：缓存空值（看业务，有的是不能缓存的）、布隆过滤器/布谷鸟过滤器
如何发现：监控应用的缓存命中率，命中率太低的肯定有问题（按经验，长期低于50%的就该注意了）

<https://www.prisma.io/dataguide/managing-databases/introduction-database-caching>
