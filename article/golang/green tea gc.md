老的gc扫描需要一个存储对象的工作队列以及每个page上需要为每个slot分配一个bit来标记状态。

这个bit位被叫做`seen bit`，它被设置说明对象进入过工作队列，说明这个对象最终是存活的。扫描结束后每个page上bit没被设置的slot会被清除。

Green Tea GC的工作队列里存的是page，而且一个page可以进出多次（对象只会进入一次）。同时每个slot增加了一个`scanned bit`。

扫描到一个对象时会把对象所在的page加入队列，然后把对象的`seen bit`设置，如果已经在队列里，则只设置`seen bit`。

从队列里去除page，查看上面的`seen bit`，设置了的slot是可能需要扫描的，这时候还要查看`scanned bit`，如果没设置则必须扫描，设置了说明扫描过了。

清理阶段看slot是否设置了`scanned bit`（理论上`seen bit`也应该被设置了），没设置的说明需要被清理。

新版gc里`seen bit`充当了page内的工作队列，标记了哪些slot需要被进一步扫描，还未处理到的slot的bit位是不会设置的，这些slot要么后面被扫描到标记上`seen bit`进入待处理状态，要么就是没人引用的到整个扫描结束都不会设置任何bit，`scanned bit`则标识了哪些对象存活。原来是`seen bit`标识哪些对象存活。

新算法可以在一个page上尽可能多处理对象，只要这些对象的`seen bit`被设置而`scanned bit`未设置，对缓存和分支预测更加友好，也避免了频繁向队列添加删除元素。

新gc在单个page上累积了多个对象的情况下可以获得最大的性能提升，但对于一个page上只能存一两个对象（体积大的对象）时性能可能会下降，因为新算法中page会出入队多次并且尽可能延迟到有多个对象积累，这些在单页上只有少量大大对象时会增加cpu负担。
