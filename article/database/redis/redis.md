## hyperloglog

用于不重复计数，记录不重复的值有多少个。
可以处理2^64-1个不同的值，最大内存占用12kb。有误差：标准值的1%左右。

pfadd key [items ...]
pfcount key 统计有多少个不同的值
pfmerge key1 key2 ...  多个hyperloglog合并为一个

在member多的情况下比set快，占用内存更小。目前会以string形式存储。

## 操作key的命令的性能风险

- keys会导致阻塞，其他的包括 hgetall、smembers、不加控制的zrange、lrange。
- 删除元素很多的set、list、hash、zset会导致阻塞
- unlink从4.2引入，它会立即删除key本身，但key持有的内存以及嵌套结构中的子成员会在另外一个线程中被释放，这样不会阻塞服务器
- rename 如果新的name有对应的内容存在，会先delete，会导致阻塞，所以最好先unlink一下new name。
- randomkey 在设置了惰性删除过期key的情况下，会先检查key是否过期，可能会导致删除大量过期key而阻塞。（5.0加了查找次数限制，默认100次）
- rename会把老key的过期时间转移到新key

## list

lrange 虽然支持负的start和stop，但没法反向遍历元素，只能自己一个个根据-1，-2用lindex获取。

## hash

7.4之前field不支持过期，之后有`HEXPIRE`等可以设置field过期，`HTTL`可以查看还有多久过期。

8.0可以用hsetex去设置：`hsetex ha FNX EX 10 FIELDS 1 f1 v1`

## key已经过了过期时间，但还能访问到

- 主从同步有延迟，导致从服务器设置过期时间比master晚了几秒（通过设置在固定的datetime过期可避免，而非设置相对时长）
- 重新set了key但没加过期时间，导致过期时间被擦除，incr、lpush、hset不会清除
- 3.2以下版本的从库不会判断key是否过期，只要master不删就能一直访问，4.0.11之后才完全修复。
- 主从时钟不同步或波动，导致一方提前过期或延后过期key

## 内存不够用后的淘汰策略
maxmemory 设置可用内存bytes数

- 不淘汰，直接拒绝写请求并返回错误，读取正常（3.0后默认策略）
- 淘汰
  1. volatile-random 随机从过期key字典里删除key
  2. ttl 先删除快过期的key
  3. lru 删除最久未使用的带过期的keyi（3.0前默认策略）
  4. lfu 删除最少使用的过期key（有些key可能刚用过一两次，但一个更久未使用的key的使用次数远多于这个key，优先删除这个key）
  5. allkeys-random 随机删除任何key（包含带过期和不带过期的）
  6. lru 所有key里最久没使用的
  7. lfu 所有key里最少使用的

近似LRU：最近最少使用的近似算法，不使用链表，因为大量增加和访问key会导致频繁的链表节点移动；
代替做法是每个key包含一个访问时间，删除的时候随机选5个（可配置）删除访问时间最久的
LRU的问题：缓存污染，前面提到的，很多只访问一两次的key被短时间大量插入，会导致删除真正有用的热点key，而这些低频key会浪费内存直到下一次清理或过期

lfu：最近最不常用，根据访问频率来决定是否删除（不是次数），redis会存最近访问时间和频率，频率会随时间推移而衰减（方式和比率可配置），每次key被访问，会先根据上次的访问时间衰减缩小频率，然后再增加。
删除的时候和lru一样，随机选取一些后比较频率，最小的删除。常见的实现结构可以是优先级队列或最小堆。

## redis key过期策略

带过期的key会被存进一个hashtable

定时删除：设置定时器，到期就删除
优点是删除比较及时，尽快释放内存
缺点是要维护很多定时器，消耗cpu资源
redis不使用这种方法

惰性删除：client过来读写的时候才检查是不是过期
优点是节约很多cpu资源
缺点是删除不及时，占用内存，如果key再也不被访问就会一直赖在内存里
save不会把已过期的key存入rdb，重新装载rdb时主库会检查key是否过期是则删除，从库不会因为需要听主库的话。
aof写入的时候不会检查是否过期，日后被删的时候追加一条del；重新加载的时候会检查加进来的key是不是过期了。主从处理同上。

定期删除：redis周期性选一些过期哈希表里的key（默认20）检查是不是过期，过期就删掉，有频率限制（1s多少次）和单次执行时长限制（25ms，可配置）
优点是平衡了cpu消耗和内存占用
缺点是有的key过期了但正好没被删且这时被访问，会取到过期无效数据

默认策略：惰性删除+定期删除，保证资源占用的平衡又不会有无效数据的问题。这玩意儿写死的，没法设置。

定期删除流程：
1. 抽20个key
2. 把过期的删掉
3. 运行时间超过25ms就停止否则继续
4. 删掉了25%以上的key，则继续去删下一轮，直到超时或者删除的数量＜25%

这样保证能尽可能多删除过期key，又不会运行时间过长导致操作key的单线程卡死。

## 操作系统内存管理导致的Redis延迟

numa硬件下redis长时间写入aof备份文件后导致page cache过多，当前node没有可用内存所以从远端node分配，带来显著延迟，page failure显著增多。

Linux倾向于把内存尽量用page cache填满，但这样做的好处是后续读取或者对同一范围的修改写入能更快，aof文件只会追加写入且平时不会读取内容，因此page cache对其效果有限甚至是无用的。

解决方案：尽量保证node或者系统中有足够的空闲内存，也就是相应减少page cache的比例。第一种办法是设置`vm.min_free_kbytes`，这个参数强制node保持最小可用空闲内存，低于这个比例就回收cache，设置得太高反而回收过多拖慢系统，设置太低则有可能导致内核崩溃。`sysctl -w vm.min_free_kbytes=1048576`，这个方案只是间接解决问题，因为调大min相应地low也会变高，系统就会更积极地启动kswapd，但风险不小。

第二种是设置`vm.watermark_scale_factor`。Linux的内存水位线有high、low、min。high表示内存充足无需回收，low会启动kswapd进行异步回收，min属于紧急情况内核会开始主动释放cache并可能暂停执行中的进程直到有可用内存。方案二这个配置是设置水位之间的距离，固定分母为10000，然后这个值做分子，组合出的分数乘以系统内内存总量。默认值10，也就是0.1%，这意味着可用内存降至high水位后，再下降整个node内存的0.1%就会变成low。gap越大，内存就会在可用数量越多的时候进入low，内核会不断回收cache直到重回high，这样就能尽快且尽可能多地回收cache，从而让出可用内存。可选值是0到3000，一般选择100到500，对于本例中redis的情况可以设置到1000也就是10%。这样redis总是能立刻分配到可用内存，不会跨node分配，也不会在分配的时候需要系统回收和写回cache导致延迟。
