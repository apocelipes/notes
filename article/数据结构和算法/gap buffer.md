文本编辑器中常见的数据结构。

gap buffer在buffer中间保留一部分未使用空间，一遍在O（1）时间内快速插入数据并且不需要移动插入位置之后的其他数据。

相比链表它对缓存更友好，数据集中在连续的内存空间里。gap不能太大，否则gap前后的数据会过于分散，同样对缓存不友好。

```golang
type GapBuffer struct {
    buf []byte
    gapStart, gapEnd int
}
```

也可以用指针指向gap的开始和结尾。

```golang
// 内存分布：
// buf: AAAABBBB----------CCCCC
//              x
// -是未使用的内存
// x是光标在的位置，这里指向最后一个B之后第一个C之前
// 光标之后永远都是gap
```

gap buffer的插入和删除比较简单，插入时往光标之后的gap里插入数据就行，位置不够就要扩容整个buffer；删除则是把start和end移动到合适的位置，如果gap过大可以考虑缩容。不扩容缩容，复杂度近似于O（1），否则O（n）。

移动光标需要gap前的内容移动到gap后：

```golang
// 移动前: AAAABBBB----------CCCCC
//                x
// 移动后：AAAAB----------BBBCCCCC
//             x
```

复杂度O（n），需要把光标前的数据向后移动到gapEnd之后。

优点：

- 缓存友好
- 实现简单
- 插入删除很快

缺点：

- 不适合大型文档，比如移动光标会变得极其缓慢
- 移动内容复杂度是O（n），也是导致上一条的原因之一
- 浪费内存，gap过大浪费，过小则会频繁扩容导致移动
- 并发不友好，连续的内存在并发访问时很多时候只能加锁
