压缩的bitmap。

传统bitmap在元素少但其中最大元素较大时会浪费很多内存，例如：`{1, 2, 100, 1001, 20001}`。

比较常见的压缩方法：行程长度编码（Run-Length Encoding, RLE）。

RLE适用于有较多连续重复数据的情况，例如：

`AAAAABBCBCCDDD` => `5A2BCB2C3D`，连续出现的频率和内容被编码，一定程度上可以压缩。

RLE的变种PackBits，对于不连续出现的数据，RLE会导致其变成2倍长度，因此PackBits把非连续部分的长度进行编码：

`AAAAABCBCBCDDDD` => `A5B1C1B1C1B1C1D4` => `5A-6BCBCBC4D`，这样可以避免数据增加不需要的长度。

RLE使得数据的查找，合并，交集等变得缓慢，使时间复杂度从`O(min(a, b))`变为`O(a + b)`。且对于稀疏但非连续的数据压缩率很低。

所以Roaring Bitmap选择了混合压缩策略。

Roaring使用“基数”作为索引，将整数划分为一个个chunk。

Roaring把一个32位无符号整数分为两部分：

```text
0B 0000000000000000 1101110011101011
  |    16 bit      |     16 bit     |
```

最高有效位16位会被作为索引，有共同索引的数字会被放在同一个chunk里。

剩下的16位则作为数字在chunk里的标识，索引拼接上标识就是真正存进去的数字。

一个典型的Roaring的结构像下面这样：

```golang
type Roaring struct {
    keys   []uint16    // keys必须有序排列
    chunks []container // 和keys在数组中的位置必须一一对应
}
```

由此可见，一个chunk里最多容纳 `2^16 - 1` 即 65535个 数字。

查找数字对应的chunk是这样的：

1. 取数字16bit最高有效位
2. 用二分查找找到在keys里的index
3. 用index访问chunks，得到数字所在的chunk

为什么用二分查找而不是hashtable？

因为一个chunk能容纳65535个连续数字，5个chunk相当于有30w+个数字，通常的应用chunk的规模不会超过一个数量级。5个uint16很小两到三个cache line就能容纳，比hashtable对缓存更友好，而且也比hashtable更节约内存。在这个数据规模上二分查找并不比hash慢。

container分为好几种，对应不同的压缩策略。

### uint16数组容器

用于稀疏的chunk，标准是chunk里元素不多于4096个。

元素按16bit的标识数据排序后存放在uint16的数组里，查找，插入，删除均使用二分查找定位元素位置。

用二分查找理由同上。

好处：压缩率比较理想，遍历也快
缺点：查找和变更都会比较慢

选4096作为阈值应该是超过这个值之后二分查找的效率已经不够理想了，因为数据越多每次查找跳跃的范围就越大，对缓存命中和分支预测都很不利。

### 传统bitmap

超过4096个元素后chunk会转换成普通bitmap，占用8k内存，可以容纳8192 * 8个元素。

### RLE容器

针对有大量连续1或者0的chunk，转换成RLE容器。

好处：极大压缩内存用量
坏处：操作比有序数组更慢一点

还有其他一些容器常用的就是这三类。合理搭配压缩策略可以兼顾性能和压缩率。

不同容器针对遍历以及交集并集等聚合操作都有优化。

使用场景：有较多数字且数字间较为分散的场合；非常在意内存用量并愿意为之牺牲一部分性能。
